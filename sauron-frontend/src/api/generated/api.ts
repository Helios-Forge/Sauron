/* tslint:disable */
/* eslint-disable */
/**
 * Sauron Backend API
 * A comprehensive API for managing firearm parts, models, and compatibility.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Rules defining compatibility between different parts and firearm models
 * @export
 * @interface SauronBackendInternalModelsCompatibilityRule
 */
export interface SauronBackendInternalModelsCompatibilityRule {
    /**
     * Compatible part in the relationship
     * @type {SauronBackendInternalModelsPart}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'compatible_with_part'?: SauronBackendInternalModelsPart;
    /**
     * ID of the part that is compatible with the primary part
     * @type {number}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'compatible_with_part_id'?: number;
    /**
     * Type of compatibility constraint (e.g., \"required\", \"optional\", \"incompatible\")
     * @type {string}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'constraint_type'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'created_at'?: string;
    /**
     * Additional details about the compatibility rule @Description JSON object containing specific compatibility details
     * @type {string}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'details'?: string;
    /**
     * Related firearm model
     * @type {SauronBackendInternalModelsFirearmModel}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'firearm_model'?: SauronBackendInternalModelsFirearmModel;
    /**
     * ID of the firearm model this rule applies to
     * @type {number}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'firearm_model_id'?: number;
    /**
     * Unique identifier for the compatibility rule
     * @type {number}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'id'?: number;
    /**
     * Primary part in the compatibility relationship
     * @type {SauronBackendInternalModelsPart}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'part'?: SauronBackendInternalModelsPart;
    /**
     * ID of the primary part in this compatibility rule
     * @type {number}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'part_id'?: number;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsCompatibilityRule
     */
    'updated_at'?: string;
}
/**
 * Firearm model information including required and compatible parts
 * @export
 * @interface SauronBackendInternalModelsFirearmModel
 */
export interface SauronBackendInternalModelsFirearmModel {
    /**
     * Category of the firearm
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'category'?: string;
    /**
     * List of compatible parts for this firearm model @Description JSON array of compatible part categories
     * @type {Array<string>}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'compatible_parts'?: Array<string>;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'created_at'?: string;
    /**
     * Unique identifier for the firearm model
     * @type {number}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'id'?: number;
    /**
     * Name of the firearm model
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'name'?: string;
    /**
     * List of required parts for this firearm model @Description JSON array of required part names
     * @type {Array<string>}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'required_parts'?: Array<string>;
    /**
     * Subcategory of the firearm
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'subcategory'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'updated_at'?: string;
    /**
     * Variant of the firearm model
     * @type {string}
     * @memberof SauronBackendInternalModelsFirearmModel
     */
    'variant'?: string;
}
/**
 * Detailed information about a firearm part including compatibility and restrictions
 * @export
 * @interface SauronBackendInternalModelsPart
 */
export interface SauronBackendInternalModelsPart {
    /**
     * Main category of the part
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'category'?: string;
    /**
     * Compatibility information with other parts and models @Description JSON object containing compatibility rules
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'compatibility'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'created_at'?: string;
    /**
     * Unique identifier for the part
     * @type {number}
     * @memberof SauronBackendInternalModelsPart
     */
    'id'?: number;
    /**
     * Whether this is a pre-built component
     * @type {boolean}
     * @memberof SauronBackendInternalModelsPart
     */
    'is_prebuilt'?: boolean;
    /**
     * Legal restrictions or requirements for this part @Description JSON object containing legal restriction details
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'legal_restrictions'?: string;
    /**
     * Name of the part
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'name'?: string;
    /**
     * List of required sub-components for this part @Description JSON array of required sub-component names
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'required_sub_components'?: string;
    /**
     * List of sub-components that make up this part @Description JSON array of sub-component details
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'sub_components'?: string;
    /**
     * Subcategory for more specific classification
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'subcategory'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsPart
     */
    'updated_at'?: string;
}
/**
 * Complete firearm configuration with specific components
 * @export
 * @interface SauronBackendInternalModelsPrebuiltFirearm
 */
export interface SauronBackendInternalModelsPrebuiltFirearm {
    /**
     * List of components included in this build @Description JSON object containing component details and specifications
     * @type {string}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'components'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'created_at'?: string;
    /**
     * Base firearm model
     * @type {SauronBackendInternalModelsFirearmModel}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'firearm_model'?: SauronBackendInternalModelsFirearmModel;
    /**
     * ID of the base firearm model
     * @type {number}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'firearm_model_id'?: number;
    /**
     * Unique identifier for the prebuilt firearm
     * @type {number}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'id'?: number;
    /**
     * Name of the prebuilt configuration
     * @type {string}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'name'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsPrebuiltFirearm
     */
    'updated_at'?: string;
}
/**
 * Product listing information including pricing and availability
 * @export
 * @interface SauronBackendInternalModelsProductListing
 */
export interface SauronBackendInternalModelsProductListing {
    /**
     * Additional seller-specific information @Description JSON object containing additional product details
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'additional_info'?: string;
    /**
     * Current availability status (in_stock, out_of_stock, backorder)
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'availability'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'created_at'?: string;
    /**
     * Currency of the price
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'currency'?: string;
    /**
     * Unique identifier for the product listing
     * @type {number}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'id'?: number;
    /**
     * Last time the listing was checked/updated
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'last_checked'?: string;
    /**
     * Related part information if this is a part listing
     * @type {SauronBackendInternalModelsPart}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'part'?: SauronBackendInternalModelsPart;
    /**
     * Optional: ID of the part if this listing is for a part
     * @type {number}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'part_id'?: number;
    /**
     * Related prebuilt firearm information if this is a prebuilt listing
     * @type {SauronBackendInternalModelsPrebuiltFirearm}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'prebuilt_firearm'?: SauronBackendInternalModelsPrebuiltFirearm;
    /**
     * Optional: ID of the prebuilt firearm if this listing is for a prebuilt
     * @type {number}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'prebuilt_id'?: number;
    /**
     * Current price of the product
     * @type {number}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'price'?: number;
    /**
     * Related seller information
     * @type {SauronBackendInternalModelsSeller}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'seller'?: SauronBackendInternalModelsSeller;
    /**
     * ID of the seller offering this product
     * @type {number}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'seller_id'?: number;
    /**
     * Shipping information @Description JSON object containing shipping details
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'shipping_info'?: string;
    /**
     * Seller\'s SKU for the product
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'sku'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'updated_at'?: string;
    /**
     * URL to the product on the seller\'s website
     * @type {string}
     * @memberof SauronBackendInternalModelsProductListing
     */
    'url'?: string;
}
/**
 * Information about sellers and their API integrations
 * @export
 * @interface SauronBackendInternalModelsSeller
 */
export interface SauronBackendInternalModelsSeller {
    /**
     * API endpoint for the seller\'s integration
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'api_endpoint'?: string;
    /**
     * Encrypted API key for authentication
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'api_key'?: string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'created_at'?: string;
    /**
     * Unique identifier for the seller
     * @type {number}
     * @memberof SauronBackendInternalModelsSeller
     */
    'id'?: number;
    /**
     * Name of the seller
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'name'?: string;
    /**
     * Additional seller-specific settings @Description JSON object containing seller configuration
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'settings'?: string;
    /**
     * Current status of the seller (active, inactive, suspended)
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'status'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'updated_at'?: string;
    /**
     * Website URL of the seller
     * @type {string}
     * @memberof SauronBackendInternalModelsSeller
     */
    'website'?: string;
}
/**
 * User suggestions for new content or improvements
 * @export
 * @interface SauronBackendInternalModelsUserSuggestion
 */
export interface SauronBackendInternalModelsUserSuggestion {
    /**
     * Creation timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'created_at'?: string;
    /**
     * Unique identifier for the suggestion
     * @type {number}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'id'?: number;
    /**
     * Name of the suggested model or part
     * @type {string}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'model_name'?: string;
    /**
     * Current status of the suggestion (pending, approved, rejected)
     * @type {string}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'status'?: string;
    /**
     * List of suggested parts or modifications @Description JSON object containing detailed suggestions
     * @type {string}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'suggested_parts'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof SauronBackendInternalModelsUserSuggestion
     */
    'updated_at'?: string;
}

/**
 * CompatibilityRulesApi - axios parameter creator
 * @export
 */
export const CompatibilityRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if two parts are compatible for a specific firearm model
         * @summary Check parts compatibility
         * @param {number} firearmId Firearm Model ID
         * @param {number} part1 First Part ID
         * @param {number} part2 Second Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityCheckGet: async (firearmId: number, part1: number, part2: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firearmId' is not null or undefined
            assertParamExists('compatibilityCheckGet', 'firearmId', firearmId)
            // verify required parameter 'part1' is not null or undefined
            assertParamExists('compatibilityCheckGet', 'part1', part1)
            // verify required parameter 'part2' is not null or undefined
            assertParamExists('compatibilityCheckGet', 'part2', part2)
            const localVarPath = `/compatibility-check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firearmId !== undefined) {
                localVarQueryParameter['firearmId'] = firearmId;
            }

            if (part1 !== undefined) {
                localVarQueryParameter['part1'] = part1;
            }

            if (part2 !== undefined) {
                localVarQueryParameter['part2'] = part2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all compatibility rules for a specific firearm model and part
         * @summary Get compatibility rules by firearm and part
         * @param {number} firearmId Firearm Model ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesFirearmFirearmIdPartPartIdGet: async (firearmId: number, partId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firearmId' is not null or undefined
            assertParamExists('compatibilityRulesFirearmFirearmIdPartPartIdGet', 'firearmId', firearmId)
            // verify required parameter 'partId' is not null or undefined
            assertParamExists('compatibilityRulesFirearmFirearmIdPartPartIdGet', 'partId', partId)
            const localVarPath = `/compatibility-rules/firearm/{firearmId}/part/{partId}`
                .replace(`{${"firearmId"}}`, encodeURIComponent(String(firearmId)))
                .replace(`{${"partId"}}`, encodeURIComponent(String(partId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all compatibility rules in the database
         * @summary Get all compatibility rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/compatibility-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific compatibility rule
         * @summary Delete a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compatibilityRulesIdDelete', 'id', id)
            const localVarPath = `/compatibility-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific compatibility rule
         * @summary Get a compatibility rule by ID
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compatibilityRulesIdGet', 'id', id)
            const localVarPath = `/compatibility-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific compatibility rule
         * @summary Update a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Updated Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdPut: async (id: number, rule: SauronBackendInternalModelsCompatibilityRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('compatibilityRulesIdPut', 'id', id)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('compatibilityRulesIdPut', 'rule', rule)
            const localVarPath = `/compatibility-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all compatibility rules for a specific part
         * @summary Get compatibility rules by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesPartPartIdGet: async (partId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partId' is not null or undefined
            assertParamExists('compatibilityRulesPartPartIdGet', 'partId', partId)
            const localVarPath = `/compatibility-rules/part/{partId}`
                .replace(`{${"partId"}}`, encodeURIComponent(String(partId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new compatibility rule to the database
         * @summary Create a new compatibility rule
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesPost: async (rule: SauronBackendInternalModelsCompatibilityRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('compatibilityRulesPost', 'rule', rule)
            const localVarPath = `/compatibility-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompatibilityRulesApi - functional programming interface
 * @export
 */
export const CompatibilityRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompatibilityRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if two parts are compatible for a specific firearm model
         * @summary Check parts compatibility
         * @param {number} firearmId Firearm Model ID
         * @param {number} part1 First Part ID
         * @param {number} part2 Second Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityCheckGet(firearmId: number, part1: number, part2: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityCheckGet(firearmId, part1, part2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityCheckGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all compatibility rules for a specific firearm model and part
         * @summary Get compatibility rules by firearm and part
         * @param {number} firearmId Firearm Model ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId: number, partId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId, partId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesFirearmFirearmIdPartPartIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all compatibility rules in the database
         * @summary Get all compatibility rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific compatibility rule
         * @summary Delete a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific compatibility rule
         * @summary Get a compatibility rule by ID
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsCompatibilityRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific compatibility rule
         * @summary Update a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Updated Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesIdPut(id: number, rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsCompatibilityRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesIdPut(id, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all compatibility rules for a specific part
         * @summary Get compatibility rules by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesPartPartIdGet(partId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesPartPartIdGet(partId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesPartPartIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new compatibility rule to the database
         * @summary Create a new compatibility rule
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compatibilityRulesPost(rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsCompatibilityRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compatibilityRulesPost(rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompatibilityRulesApi.compatibilityRulesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompatibilityRulesApi - factory interface
 * @export
 */
export const CompatibilityRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompatibilityRulesApiFp(configuration)
    return {
        /**
         * Check if two parts are compatible for a specific firearm model
         * @summary Check parts compatibility
         * @param {number} firearmId Firearm Model ID
         * @param {number} part1 First Part ID
         * @param {number} part2 Second Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityCheckGet(firearmId: number, part1: number, part2: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.compatibilityCheckGet(firearmId, part1, part2, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all compatibility rules for a specific firearm model and part
         * @summary Get compatibility rules by firearm and part
         * @param {number} firearmId Firearm Model ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId: number, partId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>> {
            return localVarFp.compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId, partId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all compatibility rules in the database
         * @summary Get all compatibility rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>> {
            return localVarFp.compatibilityRulesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific compatibility rule
         * @summary Delete a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.compatibilityRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific compatibility rule
         * @summary Get a compatibility rule by ID
         * @param {number} id Compatibility Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsCompatibilityRule> {
            return localVarFp.compatibilityRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific compatibility rule
         * @summary Update a compatibility rule
         * @param {number} id Compatibility Rule ID
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Updated Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesIdPut(id: number, rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsCompatibilityRule> {
            return localVarFp.compatibilityRulesIdPut(id, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all compatibility rules for a specific part
         * @summary Get compatibility rules by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesPartPartIdGet(partId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsCompatibilityRule>> {
            return localVarFp.compatibilityRulesPartPartIdGet(partId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new compatibility rule to the database
         * @summary Create a new compatibility rule
         * @param {SauronBackendInternalModelsCompatibilityRule} rule Compatibility Rule Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compatibilityRulesPost(rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsCompatibilityRule> {
            return localVarFp.compatibilityRulesPost(rule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompatibilityRulesApi - object-oriented interface
 * @export
 * @class CompatibilityRulesApi
 * @extends {BaseAPI}
 */
export class CompatibilityRulesApi extends BaseAPI {
    /**
     * Check if two parts are compatible for a specific firearm model
     * @summary Check parts compatibility
     * @param {number} firearmId Firearm Model ID
     * @param {number} part1 First Part ID
     * @param {number} part2 Second Part ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityCheckGet(firearmId: number, part1: number, part2: number, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityCheckGet(firearmId, part1, part2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all compatibility rules for a specific firearm model and part
     * @summary Get compatibility rules by firearm and part
     * @param {number} firearmId Firearm Model ID
     * @param {number} partId Part ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId: number, partId: number, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesFirearmFirearmIdPartPartIdGet(firearmId, partId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all compatibility rules in the database
     * @summary Get all compatibility rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesGet(options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific compatibility rule
     * @summary Delete a compatibility rule
     * @param {number} id Compatibility Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific compatibility rule
     * @summary Get a compatibility rule by ID
     * @param {number} id Compatibility Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesIdGet(id: number, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific compatibility rule
     * @summary Update a compatibility rule
     * @param {number} id Compatibility Rule ID
     * @param {SauronBackendInternalModelsCompatibilityRule} rule Updated Compatibility Rule Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesIdPut(id: number, rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesIdPut(id, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all compatibility rules for a specific part
     * @summary Get compatibility rules by part ID
     * @param {number} partId Part ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesPartPartIdGet(partId: number, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesPartPartIdGet(partId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new compatibility rule to the database
     * @summary Create a new compatibility rule
     * @param {SauronBackendInternalModelsCompatibilityRule} rule Compatibility Rule Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompatibilityRulesApi
     */
    public compatibilityRulesPost(rule: SauronBackendInternalModelsCompatibilityRule, options?: RawAxiosRequestConfig) {
        return CompatibilityRulesApiFp(this.configuration).compatibilityRulesPost(rule, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FirearmModelsApi - axios parameter creator
 * @export
 */
export const FirearmModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all firearm models in the database
         * @summary Get all firearm models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/firearm-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific firearm model
         * @summary Delete a firearm model
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('firearmModelsIdDelete', 'id', id)
            const localVarPath = `/firearm-models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific firearm model
         * @summary Get a firearm model by ID
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('firearmModelsIdGet', 'id', id)
            const localVarPath = `/firearm-models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific firearm model
         * @summary Update a firearm model
         * @param {number} id Firearm Model ID
         * @param {SauronBackendInternalModelsFirearmModel} model Updated Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdPut: async (id: number, model: SauronBackendInternalModelsFirearmModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('firearmModelsIdPut', 'id', id)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('firearmModelsIdPut', 'model', model)
            const localVarPath = `/firearm-models/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new firearm model to the database
         * @summary Create a new firearm model
         * @param {SauronBackendInternalModelsFirearmModel} model Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsPost: async (model: SauronBackendInternalModelsFirearmModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('firearmModelsPost', 'model', model)
            const localVarPath = `/firearm-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FirearmModelsApi - functional programming interface
 * @export
 */
export const FirearmModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FirearmModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all firearm models in the database
         * @summary Get all firearm models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firearmModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsFirearmModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firearmModelsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirearmModelsApi.firearmModelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific firearm model
         * @summary Delete a firearm model
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firearmModelsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firearmModelsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirearmModelsApi.firearmModelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific firearm model
         * @summary Get a firearm model by ID
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firearmModelsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsFirearmModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firearmModelsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirearmModelsApi.firearmModelsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific firearm model
         * @summary Update a firearm model
         * @param {number} id Firearm Model ID
         * @param {SauronBackendInternalModelsFirearmModel} model Updated Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firearmModelsIdPut(id: number, model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsFirearmModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firearmModelsIdPut(id, model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirearmModelsApi.firearmModelsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new firearm model to the database
         * @summary Create a new firearm model
         * @param {SauronBackendInternalModelsFirearmModel} model Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async firearmModelsPost(model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsFirearmModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.firearmModelsPost(model, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FirearmModelsApi.firearmModelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FirearmModelsApi - factory interface
 * @export
 */
export const FirearmModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FirearmModelsApiFp(configuration)
    return {
        /**
         * Get a list of all firearm models in the database
         * @summary Get all firearm models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsFirearmModel>> {
            return localVarFp.firearmModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific firearm model
         * @summary Delete a firearm model
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.firearmModelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific firearm model
         * @summary Get a firearm model by ID
         * @param {number} id Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsFirearmModel> {
            return localVarFp.firearmModelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific firearm model
         * @summary Update a firearm model
         * @param {number} id Firearm Model ID
         * @param {SauronBackendInternalModelsFirearmModel} model Updated Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsIdPut(id: number, model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsFirearmModel> {
            return localVarFp.firearmModelsIdPut(id, model, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new firearm model to the database
         * @summary Create a new firearm model
         * @param {SauronBackendInternalModelsFirearmModel} model Firearm Model Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        firearmModelsPost(model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsFirearmModel> {
            return localVarFp.firearmModelsPost(model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FirearmModelsApi - object-oriented interface
 * @export
 * @class FirearmModelsApi
 * @extends {BaseAPI}
 */
export class FirearmModelsApi extends BaseAPI {
    /**
     * Get a list of all firearm models in the database
     * @summary Get all firearm models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirearmModelsApi
     */
    public firearmModelsGet(options?: RawAxiosRequestConfig) {
        return FirearmModelsApiFp(this.configuration).firearmModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific firearm model
     * @summary Delete a firearm model
     * @param {number} id Firearm Model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirearmModelsApi
     */
    public firearmModelsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return FirearmModelsApiFp(this.configuration).firearmModelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific firearm model
     * @summary Get a firearm model by ID
     * @param {number} id Firearm Model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirearmModelsApi
     */
    public firearmModelsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return FirearmModelsApiFp(this.configuration).firearmModelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific firearm model
     * @summary Update a firearm model
     * @param {number} id Firearm Model ID
     * @param {SauronBackendInternalModelsFirearmModel} model Updated Firearm Model Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirearmModelsApi
     */
    public firearmModelsIdPut(id: number, model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig) {
        return FirearmModelsApiFp(this.configuration).firearmModelsIdPut(id, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new firearm model to the database
     * @summary Create a new firearm model
     * @param {SauronBackendInternalModelsFirearmModel} model Firearm Model Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FirearmModelsApi
     */
    public firearmModelsPost(model: SauronBackendInternalModelsFirearmModel, options?: RawAxiosRequestConfig) {
        return FirearmModelsApiFp(this.configuration).firearmModelsPost(model, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PrebuiltFirearmsApi - axios parameter creator
 * @export
 */
export const PrebuiltFirearmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all prebuilt firearms in the database
         * @summary Get all prebuilt firearms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/prebuilt-firearms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific prebuilt firearm
         * @summary Delete a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('prebuiltFirearmsIdDelete', 'id', id)
            const localVarPath = `/prebuilt-firearms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific prebuilt firearm
         * @summary Get a prebuilt firearm by ID
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('prebuiltFirearmsIdGet', 'id', id)
            const localVarPath = `/prebuilt-firearms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific prebuilt firearm
         * @summary Update a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Updated Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdPut: async (id: number, firearm: SauronBackendInternalModelsPrebuiltFirearm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('prebuiltFirearmsIdPut', 'id', id)
            // verify required parameter 'firearm' is not null or undefined
            assertParamExists('prebuiltFirearmsIdPut', 'firearm', firearm)
            const localVarPath = `/prebuilt-firearms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firearm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all prebuilt firearms for a specific firearm model
         * @summary Get prebuilt firearms by model
         * @param {number} modelId Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsModelModelIdGet: async (modelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('prebuiltFirearmsModelModelIdGet', 'modelId', modelId)
            const localVarPath = `/prebuilt-firearms/model/{modelId}`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new prebuilt firearm to the database
         * @summary Create a new prebuilt firearm
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsPost: async (firearm: SauronBackendInternalModelsPrebuiltFirearm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'firearm' is not null or undefined
            assertParamExists('prebuiltFirearmsPost', 'firearm', firearm)
            const localVarPath = `/prebuilt-firearms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(firearm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrebuiltFirearmsApi - functional programming interface
 * @export
 */
export const PrebuiltFirearmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrebuiltFirearmsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all prebuilt firearms in the database
         * @summary Get all prebuilt firearms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsPrebuiltFirearm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific prebuilt firearm
         * @summary Delete a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific prebuilt firearm
         * @summary Get a prebuilt firearm by ID
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific prebuilt firearm
         * @summary Update a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Updated Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsIdPut(id: number, firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsIdPut(id, firearm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all prebuilt firearms for a specific firearm model
         * @summary Get prebuilt firearms by model
         * @param {number} modelId Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsModelModelIdGet(modelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsPrebuiltFirearm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsModelModelIdGet(modelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsModelModelIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new prebuilt firearm to the database
         * @summary Create a new prebuilt firearm
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prebuiltFirearmsPost(firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prebuiltFirearmsPost(firearm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PrebuiltFirearmsApi.prebuiltFirearmsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PrebuiltFirearmsApi - factory interface
 * @export
 */
export const PrebuiltFirearmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrebuiltFirearmsApiFp(configuration)
    return {
        /**
         * Get a list of all prebuilt firearms in the database
         * @summary Get all prebuilt firearms
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsPrebuiltFirearm>> {
            return localVarFp.prebuiltFirearmsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific prebuilt firearm
         * @summary Delete a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.prebuiltFirearmsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific prebuilt firearm
         * @summary Get a prebuilt firearm by ID
         * @param {number} id Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm> {
            return localVarFp.prebuiltFirearmsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific prebuilt firearm
         * @summary Update a prebuilt firearm
         * @param {number} id Prebuilt Firearm ID
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Updated Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsIdPut(id: number, firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm> {
            return localVarFp.prebuiltFirearmsIdPut(id, firearm, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all prebuilt firearms for a specific firearm model
         * @summary Get prebuilt firearms by model
         * @param {number} modelId Firearm Model ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsModelModelIdGet(modelId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsPrebuiltFirearm>> {
            return localVarFp.prebuiltFirearmsModelModelIdGet(modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new prebuilt firearm to the database
         * @summary Create a new prebuilt firearm
         * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Prebuilt Firearm Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prebuiltFirearmsPost(firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsPrebuiltFirearm> {
            return localVarFp.prebuiltFirearmsPost(firearm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrebuiltFirearmsApi - object-oriented interface
 * @export
 * @class PrebuiltFirearmsApi
 * @extends {BaseAPI}
 */
export class PrebuiltFirearmsApi extends BaseAPI {
    /**
     * Get a list of all prebuilt firearms in the database
     * @summary Get all prebuilt firearms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsGet(options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific prebuilt firearm
     * @summary Delete a prebuilt firearm
     * @param {number} id Prebuilt Firearm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific prebuilt firearm
     * @summary Get a prebuilt firearm by ID
     * @param {number} id Prebuilt Firearm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific prebuilt firearm
     * @summary Update a prebuilt firearm
     * @param {number} id Prebuilt Firearm ID
     * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Updated Prebuilt Firearm Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsIdPut(id: number, firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsIdPut(id, firearm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all prebuilt firearms for a specific firearm model
     * @summary Get prebuilt firearms by model
     * @param {number} modelId Firearm Model ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsModelModelIdGet(modelId: number, options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsModelModelIdGet(modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new prebuilt firearm to the database
     * @summary Create a new prebuilt firearm
     * @param {SauronBackendInternalModelsPrebuiltFirearm} firearm Prebuilt Firearm Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrebuiltFirearmsApi
     */
    public prebuiltFirearmsPost(firearm: SauronBackendInternalModelsPrebuiltFirearm, options?: RawAxiosRequestConfig) {
        return PrebuiltFirearmsApiFp(this.configuration).prebuiltFirearmsPost(firearm, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductListingsApi - axios parameter creator
 * @export
 */
export const ProductListingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all product listings in the database
         * @summary Get all product listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/listings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the availability and optionally the price of a specific listing
         * @summary Update listing availability
         * @param {number} id Product Listing ID
         * @param {object} availability Availability Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdAvailabilityPatch: async (id: number, availability: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingsIdAvailabilityPatch', 'id', id)
            // verify required parameter 'availability' is not null or undefined
            assertParamExists('listingsIdAvailabilityPatch', 'availability', availability)
            const localVarPath = `/listings/{id}/availability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(availability, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific product listing
         * @summary Delete a product listing
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingsIdDelete', 'id', id)
            const localVarPath = `/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific product listing
         * @summary Get a product listing by ID
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingsIdGet', 'id', id)
            const localVarPath = `/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific product listing
         * @summary Update a product listing
         * @param {number} id Product Listing ID
         * @param {SauronBackendInternalModelsProductListing} listing Updated Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdPut: async (id: number, listing: SauronBackendInternalModelsProductListing, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listingsIdPut', 'id', id)
            // verify required parameter 'listing' is not null or undefined
            assertParamExists('listingsIdPut', 'listing', listing)
            const localVarPath = `/listings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all product listings for a specific part
         * @summary Get listings by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPartPartIdGet: async (partId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partId' is not null or undefined
            assertParamExists('listingsPartPartIdGet', 'partId', partId)
            const localVarPath = `/listings/part/{partId}`
                .replace(`{${"partId"}}`, encodeURIComponent(String(partId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new product listing to the database
         * @summary Create a new product listing
         * @param {SauronBackendInternalModelsProductListing} listing Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPost: async (listing: SauronBackendInternalModelsProductListing, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listing' is not null or undefined
            assertParamExists('listingsPost', 'listing', listing)
            const localVarPath = `/listings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listing, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all product listings for a specific prebuilt firearm
         * @summary Get listings by prebuilt ID
         * @param {number} prebuiltId Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPrebuiltPrebuiltIdGet: async (prebuiltId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prebuiltId' is not null or undefined
            assertParamExists('listingsPrebuiltPrebuiltIdGet', 'prebuiltId', prebuiltId)
            const localVarPath = `/listings/prebuilt/{prebuiltId}`
                .replace(`{${"prebuiltId"}}`, encodeURIComponent(String(prebuiltId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all product listings for a specific seller
         * @summary Get listings by seller
         * @param {number} sellerId Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsSellerSellerIdGet: async (sellerId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sellerId' is not null or undefined
            assertParamExists('listingsSellerSellerIdGet', 'sellerId', sellerId)
            const localVarPath = `/listings/seller/{sellerId}`
                .replace(`{${"sellerId"}}`, encodeURIComponent(String(sellerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductListingsApi - functional programming interface
 * @export
 */
export const ProductListingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductListingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all product listings in the database
         * @summary Get all product listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsProductListing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the availability and optionally the price of a specific listing
         * @summary Update listing availability
         * @param {number} id Product Listing ID
         * @param {object} availability Availability Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsIdAvailabilityPatch(id: number, availability: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsIdAvailabilityPatch(id, availability, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsIdAvailabilityPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific product listing
         * @summary Delete a product listing
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific product listing
         * @summary Get a product listing by ID
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific product listing
         * @summary Update a product listing
         * @param {number} id Product Listing ID
         * @param {SauronBackendInternalModelsProductListing} listing Updated Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsIdPut(id: number, listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsIdPut(id, listing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all product listings for a specific part
         * @summary Get listings by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsPartPartIdGet(partId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsProductListing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsPartPartIdGet(partId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsPartPartIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new product listing to the database
         * @summary Create a new product listing
         * @param {SauronBackendInternalModelsProductListing} listing Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsPost(listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsProductListing>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsPost(listing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all product listings for a specific prebuilt firearm
         * @summary Get listings by prebuilt ID
         * @param {number} prebuiltId Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsPrebuiltPrebuiltIdGet(prebuiltId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsProductListing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsPrebuiltPrebuiltIdGet(prebuiltId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsPrebuiltPrebuiltIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all product listings for a specific seller
         * @summary Get listings by seller
         * @param {number} sellerId Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listingsSellerSellerIdGet(sellerId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsProductListing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listingsSellerSellerIdGet(sellerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductListingsApi.listingsSellerSellerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductListingsApi - factory interface
 * @export
 */
export const ProductListingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductListingsApiFp(configuration)
    return {
        /**
         * Get a list of all product listings in the database
         * @summary Get all product listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsProductListing>> {
            return localVarFp.listingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the availability and optionally the price of a specific listing
         * @summary Update listing availability
         * @param {number} id Product Listing ID
         * @param {object} availability Availability Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdAvailabilityPatch(id: number, availability: object, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsProductListing> {
            return localVarFp.listingsIdAvailabilityPatch(id, availability, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific product listing
         * @summary Delete a product listing
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listingsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific product listing
         * @summary Get a product listing by ID
         * @param {number} id Product Listing ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsProductListing> {
            return localVarFp.listingsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific product listing
         * @summary Update a product listing
         * @param {number} id Product Listing ID
         * @param {SauronBackendInternalModelsProductListing} listing Updated Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsIdPut(id: number, listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsProductListing> {
            return localVarFp.listingsIdPut(id, listing, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all product listings for a specific part
         * @summary Get listings by part ID
         * @param {number} partId Part ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPartPartIdGet(partId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsProductListing>> {
            return localVarFp.listingsPartPartIdGet(partId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new product listing to the database
         * @summary Create a new product listing
         * @param {SauronBackendInternalModelsProductListing} listing Product Listing Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPost(listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsProductListing> {
            return localVarFp.listingsPost(listing, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all product listings for a specific prebuilt firearm
         * @summary Get listings by prebuilt ID
         * @param {number} prebuiltId Prebuilt Firearm ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsPrebuiltPrebuiltIdGet(prebuiltId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsProductListing>> {
            return localVarFp.listingsPrebuiltPrebuiltIdGet(prebuiltId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all product listings for a specific seller
         * @summary Get listings by seller
         * @param {number} sellerId Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listingsSellerSellerIdGet(sellerId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsProductListing>> {
            return localVarFp.listingsSellerSellerIdGet(sellerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductListingsApi - object-oriented interface
 * @export
 * @class ProductListingsApi
 * @extends {BaseAPI}
 */
export class ProductListingsApi extends BaseAPI {
    /**
     * Get a list of all product listings in the database
     * @summary Get all product listings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsGet(options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the availability and optionally the price of a specific listing
     * @summary Update listing availability
     * @param {number} id Product Listing ID
     * @param {object} availability Availability Update Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsIdAvailabilityPatch(id: number, availability: object, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsIdAvailabilityPatch(id, availability, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific product listing
     * @summary Delete a product listing
     * @param {number} id Product Listing ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific product listing
     * @summary Get a product listing by ID
     * @param {number} id Product Listing ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific product listing
     * @summary Update a product listing
     * @param {number} id Product Listing ID
     * @param {SauronBackendInternalModelsProductListing} listing Updated Product Listing Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsIdPut(id: number, listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsIdPut(id, listing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all product listings for a specific part
     * @summary Get listings by part ID
     * @param {number} partId Part ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsPartPartIdGet(partId: number, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsPartPartIdGet(partId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new product listing to the database
     * @summary Create a new product listing
     * @param {SauronBackendInternalModelsProductListing} listing Product Listing Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsPost(listing: SauronBackendInternalModelsProductListing, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsPost(listing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all product listings for a specific prebuilt firearm
     * @summary Get listings by prebuilt ID
     * @param {number} prebuiltId Prebuilt Firearm ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsPrebuiltPrebuiltIdGet(prebuiltId: number, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsPrebuiltPrebuiltIdGet(prebuiltId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all product listings for a specific seller
     * @summary Get listings by seller
     * @param {number} sellerId Seller ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductListingsApi
     */
    public listingsSellerSellerIdGet(sellerId: number, options?: RawAxiosRequestConfig) {
        return ProductListingsApiFp(this.configuration).listingsSellerSellerIdGet(sellerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SellersApi - axios parameter creator
 * @export
 */
export const SellersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all sellers in the database
         * @summary Get all sellers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sellers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific seller
         * @summary Delete a seller
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellersIdDelete', 'id', id)
            const localVarPath = `/sellers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific seller
         * @summary Get a seller by ID
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellersIdGet', 'id', id)
            const localVarPath = `/sellers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific seller
         * @summary Update a seller
         * @param {number} id Seller ID
         * @param {SauronBackendInternalModelsSeller} seller Updated Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdPut: async (id: number, seller: SauronBackendInternalModelsSeller, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellersIdPut', 'id', id)
            // verify required parameter 'seller' is not null or undefined
            assertParamExists('sellersIdPut', 'seller', seller)
            const localVarPath = `/sellers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seller, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a specific seller
         * @summary Update seller status
         * @param {number} id Seller ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdStatusPatch: async (id: number, status: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellersIdStatusPatch', 'id', id)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('sellersIdStatusPatch', 'status', status)
            const localVarPath = `/sellers/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(status, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new seller to the database
         * @summary Create a new seller
         * @param {SauronBackendInternalModelsSeller} seller Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersPost: async (seller: SauronBackendInternalModelsSeller, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'seller' is not null or undefined
            assertParamExists('sellersPost', 'seller', seller)
            const localVarPath = `/sellers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(seller, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SellersApi - functional programming interface
 * @export
 */
export const SellersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SellersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all sellers in the database
         * @summary Get all sellers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsSeller>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific seller
         * @summary Delete a seller
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific seller
         * @summary Get a seller by ID
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsSeller>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific seller
         * @summary Update a seller
         * @param {number} id Seller ID
         * @param {SauronBackendInternalModelsSeller} seller Updated Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersIdPut(id: number, seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsSeller>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersIdPut(id, seller, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of a specific seller
         * @summary Update seller status
         * @param {number} id Seller ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsSeller>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersIdStatusPatch(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new seller to the database
         * @summary Create a new seller
         * @param {SauronBackendInternalModelsSeller} seller Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellersPost(seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsSeller>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellersPost(seller, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SellersApi.sellersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SellersApi - factory interface
 * @export
 */
export const SellersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SellersApiFp(configuration)
    return {
        /**
         * Get a list of all sellers in the database
         * @summary Get all sellers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsSeller>> {
            return localVarFp.sellersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific seller
         * @summary Delete a seller
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sellersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific seller
         * @summary Get a seller by ID
         * @param {number} id Seller ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsSeller> {
            return localVarFp.sellersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific seller
         * @summary Update a seller
         * @param {number} id Seller ID
         * @param {SauronBackendInternalModelsSeller} seller Updated Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdPut(id: number, seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsSeller> {
            return localVarFp.sellersIdPut(id, seller, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a specific seller
         * @summary Update seller status
         * @param {number} id Seller ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsSeller> {
            return localVarFp.sellersIdStatusPatch(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new seller to the database
         * @summary Create a new seller
         * @param {SauronBackendInternalModelsSeller} seller Seller Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellersPost(seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsSeller> {
            return localVarFp.sellersPost(seller, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SellersApi - object-oriented interface
 * @export
 * @class SellersApi
 * @extends {BaseAPI}
 */
export class SellersApi extends BaseAPI {
    /**
     * Get a list of all sellers in the database
     * @summary Get all sellers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersGet(options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific seller
     * @summary Delete a seller
     * @param {number} id Seller ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific seller
     * @summary Get a seller by ID
     * @param {number} id Seller ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific seller
     * @summary Update a seller
     * @param {number} id Seller ID
     * @param {SauronBackendInternalModelsSeller} seller Updated Seller Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersIdPut(id: number, seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersIdPut(id, seller, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a specific seller
     * @summary Update seller status
     * @param {number} id Seller ID
     * @param {object} status Status Update Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersIdStatusPatch(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new seller to the database
     * @summary Create a new seller
     * @param {SauronBackendInternalModelsSeller} seller Seller Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellersApi
     */
    public sellersPost(seller: SauronBackendInternalModelsSeller, options?: RawAxiosRequestConfig) {
        return SellersApiFp(this.configuration).sellersPost(seller, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSuggestionsApi - axios parameter creator
 * @export
 */
export const UserSuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all user suggestions in the database
         * @summary Get all user suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific user suggestion
         * @summary Delete a user suggestion
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSuggestionsIdDelete', 'id', id)
            const localVarPath = `/user-suggestions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific user suggestion
         * @summary Get a user suggestion by ID
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSuggestionsIdGet', 'id', id)
            const localVarPath = `/user-suggestions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a specific user suggestion
         * @summary Update a user suggestion
         * @param {number} id User Suggestion ID
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion Updated User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdPut: async (id: number, suggestion: SauronBackendInternalModelsUserSuggestion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSuggestionsIdPut', 'id', id)
            // verify required parameter 'suggestion' is not null or undefined
            assertParamExists('userSuggestionsIdPut', 'suggestion', suggestion)
            const localVarPath = `/user-suggestions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a specific user suggestion
         * @summary Update user suggestion status
         * @param {number} id User Suggestion ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdStatusPatch: async (id: number, status: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSuggestionsIdStatusPatch', 'id', id)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('userSuggestionsIdStatusPatch', 'status', status)
            const localVarPath = `/user-suggestions/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(status, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new user suggestion to the database
         * @summary Create a new user suggestion
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsPost: async (suggestion: SauronBackendInternalModelsUserSuggestion, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'suggestion' is not null or undefined
            assertParamExists('userSuggestionsPost', 'suggestion', suggestion)
            const localVarPath = `/user-suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(suggestion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user suggestions with a specific status
         * @summary Get user suggestions by status
         * @param {UserSuggestionsStatusStatusGetStatusEnum} status Suggestion Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsStatusStatusGet: async (status: UserSuggestionsStatusStatusGetStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('userSuggestionsStatusStatusGet', 'status', status)
            const localVarPath = `/user-suggestions/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSuggestionsApi - functional programming interface
 * @export
 */
export const UserSuggestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSuggestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all user suggestions in the database
         * @summary Get all user suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsUserSuggestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific user suggestion
         * @summary Delete a user suggestion
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific user suggestion
         * @summary Get a user suggestion by ID
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsUserSuggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a specific user suggestion
         * @summary Update a user suggestion
         * @param {number} id User Suggestion ID
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion Updated User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsIdPut(id: number, suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsUserSuggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsIdPut(id, suggestion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of a specific user suggestion
         * @summary Update user suggestion status
         * @param {number} id User Suggestion ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsUserSuggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsIdStatusPatch(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsIdStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new user suggestion to the database
         * @summary Create a new user suggestion
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsPost(suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SauronBackendInternalModelsUserSuggestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsPost(suggestion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all user suggestions with a specific status
         * @summary Get user suggestions by status
         * @param {UserSuggestionsStatusStatusGetStatusEnum} status Suggestion Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSuggestionsStatusStatusGet(status: UserSuggestionsStatusStatusGetStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SauronBackendInternalModelsUserSuggestion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSuggestionsStatusStatusGet(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSuggestionsApi.userSuggestionsStatusStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSuggestionsApi - factory interface
 * @export
 */
export const UserSuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSuggestionsApiFp(configuration)
    return {
        /**
         * Get a list of all user suggestions in the database
         * @summary Get all user suggestions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsUserSuggestion>> {
            return localVarFp.userSuggestionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific user suggestion
         * @summary Delete a user suggestion
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userSuggestionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific user suggestion
         * @summary Get a user suggestion by ID
         * @param {number} id User Suggestion ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsUserSuggestion> {
            return localVarFp.userSuggestionsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a specific user suggestion
         * @summary Update a user suggestion
         * @param {number} id User Suggestion ID
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion Updated User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdPut(id: number, suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsUserSuggestion> {
            return localVarFp.userSuggestionsIdPut(id, suggestion, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a specific user suggestion
         * @summary Update user suggestion status
         * @param {number} id User Suggestion ID
         * @param {object} status Status Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsUserSuggestion> {
            return localVarFp.userSuggestionsIdStatusPatch(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new user suggestion to the database
         * @summary Create a new user suggestion
         * @param {SauronBackendInternalModelsUserSuggestion} suggestion User Suggestion Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsPost(suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig): AxiosPromise<SauronBackendInternalModelsUserSuggestion> {
            return localVarFp.userSuggestionsPost(suggestion, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all user suggestions with a specific status
         * @summary Get user suggestions by status
         * @param {UserSuggestionsStatusStatusGetStatusEnum} status Suggestion Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSuggestionsStatusStatusGet(status: UserSuggestionsStatusStatusGetStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<SauronBackendInternalModelsUserSuggestion>> {
            return localVarFp.userSuggestionsStatusStatusGet(status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSuggestionsApi - object-oriented interface
 * @export
 * @class UserSuggestionsApi
 * @extends {BaseAPI}
 */
export class UserSuggestionsApi extends BaseAPI {
    /**
     * Get a list of all user suggestions in the database
     * @summary Get all user suggestions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsGet(options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific user suggestion
     * @summary Delete a user suggestion
     * @param {number} id User Suggestion ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific user suggestion
     * @summary Get a user suggestion by ID
     * @param {number} id User Suggestion ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsIdGet(id: number, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a specific user suggestion
     * @summary Update a user suggestion
     * @param {number} id User Suggestion ID
     * @param {SauronBackendInternalModelsUserSuggestion} suggestion Updated User Suggestion Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsIdPut(id: number, suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsIdPut(id, suggestion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a specific user suggestion
     * @summary Update user suggestion status
     * @param {number} id User Suggestion ID
     * @param {object} status Status Update Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsIdStatusPatch(id: number, status: object, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsIdStatusPatch(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new user suggestion to the database
     * @summary Create a new user suggestion
     * @param {SauronBackendInternalModelsUserSuggestion} suggestion User Suggestion Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsPost(suggestion: SauronBackendInternalModelsUserSuggestion, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsPost(suggestion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all user suggestions with a specific status
     * @summary Get user suggestions by status
     * @param {UserSuggestionsStatusStatusGetStatusEnum} status Suggestion Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSuggestionsApi
     */
    public userSuggestionsStatusStatusGet(status: UserSuggestionsStatusStatusGetStatusEnum, options?: RawAxiosRequestConfig) {
        return UserSuggestionsApiFp(this.configuration).userSuggestionsStatusStatusGet(status, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserSuggestionsStatusStatusGetStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;
export type UserSuggestionsStatusStatusGetStatusEnum = typeof UserSuggestionsStatusStatusGetStatusEnum[keyof typeof UserSuggestionsStatusStatusGetStatusEnum];


